## CYW20829/CYW89829 platform description

### Prerequisites

#### EdgeProtectTools

The CYW20829/CYW89829 devices have a set of security features. A special tool called `edgeprotecttools` is required to use most of them.

EdgeProtectTools is a Python package, which can be installed using the conventional `python pip` package installer:

    python -m pip install edgeprotecttools

EdgeProtectTools is used for reprovisioning of the chip, revocation of keys, security counter updates, image encryption, and more. For more details on functionality, go to [https://pypi.org/project/edgeprotecttools](https://pypi.org/project/edgeprotecttools) or [https://github.com/Infineon/edgeprotecttools#provision-device](https://github.com/Infineon/edgeprotecttools#provision-device)

Invocation of `edgeprotecttools` is built into the post-build jobs for `MCUBootApp` and `BlinkyApp`, so the user gets ready to use images after build.

Requirements for `edgeprotecttools` installation can be found [here](https://github.com/Infineon/edgeprotecttools?tab=readme-ov-file#prerequisites).

### MCUBootApp specifics
The CYW20829/CYW89829 chips can be provisioned in two modes - Non-Secure and Secure. In the Non-Secure (NORMAL_NO_SECURE) mode the CYW20829/CYW89829 works as a 'usual' Infineon chip. In the SECURE mode the following functionality becomes available:
 - signing of images;
 - rollback protection (hardware secure counter).

The work with the CYW20829/CYW89829 chips begins from the initialization of the project with the following device provisioning in the desired lifecycle - Non-Secure or Secure.

### Device and environment initialization
For the `edgeprotecttools` environment setup the `boot/cypress` folder is used.

To create a common configuration, use:

    edgeprotecttools -t <TARGET> --rev <REVISION> init

Run the following command and use the name of your <TARGET> cyw20829 or cyw89829, and <REVISION> a0, b0 or b1. If the REVISION option is not specified, the `edgeprotecttools` will use the latest revision.

To configure an OpenOCD package path (via ModusToolboxâ„¢ Programming Tools by default):

    edgeprotecttools set-ocd --name openocd --path C:/Infineon/Tools/ModusToolboxProgtools-1.5/openocd

For SECURE `LCS`, a few more steps are necessary. You will need to generate an RSA key pair (or copy it to the keys folder, if it was generated previously), to provision a chip in Secure mode:

    edgeprotecttools -t <TARGET> -p policy/policy_secure.json create-key -k 0

To get access to the chip after provisioning, a debug certificate is required:

    edgeprotecttools -t <TARGET> -p policy/policy_secure.json debug-certificate -t packets/debug_cert.json -o packets/debug_cert.bin -k 0

### CYW20829/CYW89829 provisioning and reprovisioning

For the first provision of the CYW20829 or CYW89829 chip, use:

    edgeprotecttools -t <TARGET> -p policy/policy_%LCS%.json provision-device

or

    edgeprotecttools -t <TARGET> -p policy/policy_reprovisioning_%LCS%.json reprovision-device

for the following reprovision procedure.

More details about provisioning and reprovisioning processes you can find in [README_CYW20829.md](https://github.com/Infineon/edgeprotecttools/blob/master/docs/README_CYW20829.md#command-provision-device)

### Default memory map

The repository provides a set of predefined memory maps in JSON files. They are located in `platforms/memory/CYW20829/flashmap`. One can use the predefined flash map or create your own using the predefined file as a template.

### Direct-XIP mode support

Additionally to the classic mode with `BOOT` and `UPGRADE` slots, MCUBootApp for CYW20829/CYW89829 platform supports the `Direct-XIP` mode. The main difference is that both slots, named `Primary` and `Secondary`, are equal, and the image in one slot has no effect on the other image. In this mode, MCUBootApp checks the version of the images and launches the application with the higher version number. The version number can be set via the `IMG_VER` command-line parameter. If both version numbers are equal, the image in the primary slot will be launched. The build number is not taken into account during version comparison; only the major, minor, and patch version numbers are considered.
In the `Direct-XIP` mode, both images are treated like `UPGRADE` images. This implies that each image must set the `IMG_OK` flag during its first startup. If the `IMG_OK` flag is not set, the corresponding application will be erased, and the application from the other slot will be launched. If neither application sets the `IMG_OK` flag, MCUBootApp will erase both applications. The `Direct-XIP` mode supports encrypted images. In this mode, the MCUBootApp and all images are encrypted using the same `AES-CTR` encryption key. For more information, refer to the `Encrypted image support` section.
Another change is that the `APP_SLOT` command line parameter should be used for application compilation instead of the `IMG_TYPE` parameter. Use `APP_SLOT=1` for the `Primary` slot and `APP_SLOT=2` for the `Secondary`.

To enable the `Direct-XIP` mode, use the appropriate flash map, such as `cyw20829_direct_xip_single.json`

    make clean app APP_NAME=MCUBootApp PLATFORM=CYW20829 FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_direct_xip_single.json
    make app APP_NAME=BlinkyApp PLATFORM=CYW20829 FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_direct_xip_single.json APP_SLOT=1 IMG_VER=1.0.0+100
    make app APP_NAME=BlinkyApp PLATFORM=CYW20829 FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_direct_xip_single.json APP_SLOT=2 IMG_VER=2.0.0+200

NOTE: Currently, support for the `Direct-XIP` mode is limited to the `NORMAL_NO_SECURE` lifecycle.

### Skip image validation

To decrease the boot time of MCUBootApp, image validation can be skipped before launching the application. This flow is recommended in cases where boot time is more important than reliability. To disable image validation for a selected slot, use the `MCUBOOT_SKIP_VALIDATE_PRIMARY_SLOT=1` or `MCUBOOT_SKIP_VALIDATE_SECONDARY_SLOT=1` command-line parameter.
To skip image validation entirely, the `MCUBOOT_SKIP_VALIDATE=1` option can be used.

### Direct-XIP APIs

The Direct-XIP API provides a comprehensive set of functions for managing firmware images and their associated metadata in boot slots. This API is designed to facilitate secure and reliable firmware updates in embedded systems and supports operations such as slot validation, image state management, and metadata handling. Below is a summary of the key API functions and their purposes.

- Image Validation:
Use `boot_validate_slot_for_image_id` to ensure that the firmware image in a slot is valid before executing it. This API is useful when MCUBootApp startup validation is disabled.

- Slot Management:
Use `boot_set_inactive_slot`, `boot_is_slot_inactive`, or `boot_set_pending_slot` to manage the activation and deactivation of firmware slots.

- Metadata Handling:
Use `boot_find_image_tlv_info` and `boot_read_image_tlv_value` to retrieve and parse metadata associated with firmware images.
 
- State Inspection:
Use `boot_get_slot_state` or `boot_get_image_state` to monitor and debug the current state of firmware images in the system.

- Revert Mechanism:
        Use `boot_set_revert_slot` to mark a slot for erasure on the next reboot if its firmware fails validation.


#### Slot Validation and Image Management APIs

    boot_validate_slot_for_image_id
        Description: Validates the image in a specified slot without performing a boot.
        Parameters:
            image_id: Image identifier (starting from 0).
            slot_id: Slot index (0 for primary, 1 for secondary).
        Returns: FIH_SUCCESS on success.

    boot_get_image_version
        Description: Reads the version information (major, minor, patch, and build) from the image header in the specified slot.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
            ver: Pointer to the structure where version information will be stored.
        Returns: 0 on success.

    boot_set_inactive_slot
        Description: Marks the specified slot as inactive.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
        Returns: 0 on success.

    boot_is_slot_inactive
        Description: Checks if the specified slot is inactive.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
        Returns:
            1: Slot is inactive.
            0: Slot is active.
            -1: Error occurred.

    boot_set_pending_slot
        Description: Restores an inactive slot to a pending state, making it bootable in the next cycle.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
        Returns: 0 on success.

    boot_set_revert_slot
        Description: Sets the revert state for a slot, indicating that the image will be erased on the next boot if not validated.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
        Returns: 0 on success.


#### Metadata (TLV) Handling APIs

    boot_find_image_tlv_info
        Description: Finds metadata information (Type-Length-Value) for a specific image and slot, returning the offset and length of the requested TLV entry.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
            type: TLV type identifier.
            len: Pointer to store the length of the TLV entry.
            off: Pointer to store the offset of the TLV entry.
        Returns: 0 on success, non-zero on error or if the TLV is not found.

    boot_read_image_tlv_value
        Description: Reads the actual value of a TLV entry from the specified image slot.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
            type: TLV type identifier.
            buf: Buffer to store the retrieved TLV value.
            buf_len: Length of the provided buffer.
            read_len: Pointer to store the actual number of bytes read.
        Returns: 0 on success, non-zero on error or insufficient buffer length.


#### Slot and Image State Management APIs

    boot_get_slot_state
        Description: Retrieves the current state of a specified slot without performing image validation.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
            state: Pointer to store the slot's state information.
        Returns: 0 on success, non-zero on error.

    boot_get_image_state
        Description: Retrieves the detailed state of a slot, such as active, inactive, pending, etc.
        Parameters:
            image_id: Image identifier.
            slot_id: Slot index.
            state: Pointer to store the state information of the slot.
        Returns: 0 on success, non-zero on error.

A detailed description of the API interfaces can be found in the `boot/bootutil/include/bootutil/bootutil.h` header file.

### Encrypted image support

CYW20829/CYW89829 does not have internal flash memory, so both primary and secondary images are located in external memory.

To protect the firmware from reading, place it in external memory in the encrypted form.

CYW20829/CYW89829 can execute encrypted firmware directly using the onboard hardware interface (SMIF) with special mode XIP (eXecute-In-Place). In this mode, all code is decrypted transparently by the AES algorithm.

MCUBootApp has its own Encrypted image mode to encrypt the firmware and transfer it with the AES session key included in the HKDF data block.

**MCUBootApp image validation flow**

- Decrypt the AES key / initial vector (IV) from HKDF
- Set up AES IV + CTR nonce (Image addr = base_addr + header_size)
- Read slot data by MMIO
- Decrypt the image in the slot using MCUBootApp internal functionality
- Calculate and verify hash from decrypted data
- Validate the slot image by hash and sign it

**MCUBootApp image upgrade flow**

- Read slot 1 sector data using MMIO
- Skip data decryption
- Write data to the primary slot using MMIO

**MCUBootApp Run**
- Set up SMIF registers
- Set the AES key
- Set AES IV
- Set SMIF mode to XIP
- Go to the application entry point

MCUBootApp and BlinkyApp can be built with an encrypted image plus encrypted XIP support using special build flags `ENC_IMG=1`. That flag will automatically enable XIP mode.

Example build command for MCUBootApp:

    make clean app APP_NAME=MCUBootApp PLATFORM=CYW20829 BUILDCFG=Debug FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_xip_swap_single.json ENC_IMG=1

Example build command for BlinkyApp:

    make clean app APP_NAME=BlinkyApp PLATFORM=CYW20829 BUILDCFG=Debug FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_xip_swap_single.json ENC_IMG=1

NOTE: In the case where a common AES-CTR key is used to encrypt both the MCUBootApp and BlinkyApp applications, MCUBoot should be compiled first. This is because the common NONCE file for the AES-CTR algorithm is generated during the MCUBootApp compilation. Since BlinkyApp will use the same NONCE file, it should be compiled after MCUBootApp. This also applies to cases where MCUBootApp is recompiled and a new NONCE file is generated.

#### Encrypted image support using secured encryption key

The CYW20829/CYW89829 MCU supports on-the-fly XIP (eXecute In Place) encryption utilizing a provisioned AES-128 key in both `SECURE` and  `NORMAL_NO_SECURE` lifecycles. SMIF encryption can be enabled only once, during the first device provisioning, and cannot be changed in the future.
Information about key generation for image encryption and device provisioning can be found in the documentation for the EdgeProtectTools utility:
https://github.com/Infineon/edgeprotecttools/blob/master/docs/README_CYW20829.md#encrypt-the-user-application

NOTE: To enable SMIF encryption in the `NORMAL_NO_SECURE` LCS, you will need at least EdgeProtectTools version 1.5.0, and B0 revision of the silicon (or later).

##### Enabling XIP Encryption

To enable this feature, you need to specify an additional make parameter `SMIF_ENC=1` during the build process.

##### Build Example

Use the following commands to build your application with XIP encryption enabled:

```sh
make clean app APP_NAME=MCUBootApp PLATFORM=CYW20829 BUILDCFG=Debug FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_xip_swap_single.json LCS=SECURE SMIF_ENC=1

make clean app APP_NAME=BlinkyApp PLATFORM=CYW20829 BUILDCFG=Debug FLASH_MAP=./platforms/memory/CYW20829/flashmap/cyw20829_xip_swap_single.json IMG_TYPE=UPGRADE SMIF_ENC=1
```

##### Preparing and Encrypting Application Images
Users must prepare non-encrypted signed images for their applications and perform manual encryption using `edgeprotecttools` with the "encrypt" command. This command requires specifying the encryption key, nonce, and image address as the initial vector (IV).

##### Encryption Example
To encrypt your application binary, use the following command:

```sh
edgeprotecttools -t <TARGET> encrypt --input BlinkyApp.bin --output BlinkyApp_encrypted.bin --iv 0x08020000 --enckey keys/encrypt_key.bin --nonce ./MCUBootApp/out/<TARGET>/Debug/MCUBootApp.signed_nonce.bin
```

**Parameters:**
- --input: The input application binary file (e.g., BlinkyApp.bin).
- --output: The output encrypted application binary file (e.g., BlinkyApp_encrypted.bin).
- --iv: The initial vector, which must be equal to the application start CBUS address. For example, if the application start address is 0x60020000, it should be converted to 0x08020000.
- --enckey: The path to the encryption key file (e.g., keys/encrypt_key.bin).
- --nonce: The nonce used for MCUBootApp encryption. Specify the path to the autogenerated nonce file (e.g., ./MCUBootApp/out/CYW20829/Debug/MCUBootApp.signed_nonce.bin).

By following these steps, you can ensure that your application binaries are securely encrypted and ready for execution on the CYW20829/CYW89829 MCU with on-the-fly XIP encryption enabled.

##### USE_IMG_TRAILER Parameter Description
The `USE_IMG_TRAILER` parameter provides developers with the ability to disable the generation of the image trailer and padding between the image body and the trailer, reducing the image size. This feature is useful for encrypted images. Padding bytes in encrypted images are transformed into random data, making the image size non-compressible. Disabling the trailer and padding reduces unnecessary overhead in such cases. By default, this parameter is enabled `USE_IMG_TRAILER=1`.

**Warning:** Disabling the image trailer and padding is supported for Direct-XIP mode only.

To disable the trailer and padding, set `USE_IMG_TRAILER=0` during the build process:
```sh
 make app APP_NAME=BlinkyApp PLATFORM=CYW20829 FLASH_MAP=platforms/memory/CYW20829/flashmap/cyw20829_direct_xip_single.json APP_SLOT=1 IMG_VER=1.0.0+100 USE_IMG_TRAILER=0
```
NOTE: The application slot must be erased before programming the image with `USE_IMG_TRAILER=0`.

### Rollback protection Support

As mentioned above, to use the rollback protection feature the device must be transferred to the SECURE lifecycle. The CYW20829/CYW89829 platform has a hardware-supported feature - a non-volatile counter (NV-counter). This feature is used by the MCUboot library to implement the rollback protection counter (security counter). NV-counter on CYW20829/CYW89829 is implemented as an eFuse-type region that can only be incremented. This means, that each time a new counter value is updated - a corresponding number of eFuse is burned.

The initial value of the rollback counter is programmed into the chip at the provisioning stage. The provisioning policy for Secure mode contains a corresponding field (file `policy/policy_secure.json`):


        "reprovisioning":
        {
            "nv_counter": {
                "description": "Anti-rollback counter. Each item of the 'value' array defines counter for each next application. Each 'bits_per_cnt' item defines number of bits for the next application counter (total bits number 32). IMPORTANT: 'bits_per_cnt' in the provisioning and reprovisioning policy files MUST BE the same",
                "value": [0],
                "bits_per_cnt": [32]
            },

or 

        "reprovisioning":
        {
            "nv_counter": {
                "description": "Anti-rollback counter. Each item of the 'value' array defines counter for each next application. Each 'bits_per_cnt' item defines number of bits for the next application counter (total bits number 32). IMPORTANT: 'bits_per_cnt' in the provisioning and reprovisioning policy files MUST BE the same",
                "value": [0, 0],
                "bits_per_cnt": [24, 8]
            },

for multi-image case (2 images).

If the `nv_counter` value is left untouched, any image with counters higher than 0 and less than value defined by `bits_per_cnt` (or equal to) can be programmed into the chip.

`bits_per_cnt` also defines a distribution of eFuse among images in system. For example, in the first case MCUBootApp is considered to be single image configuration with all 32 available eFuses dedicated to this one image.

In the second case MCUBootApp is considered to be multi-image configuration with 2 images. 24 bits of 32 available eFuses are dedicated to image id 1, and 8 bits to image id 2. 

This distribution can be changed by user at initial provisioning stage and SHOULD NOT be changed at later reprovisioning stages.

`"value": [2, 3]` field sets corresponding value for image ids. Here `2` would be assigned to image id `1` and `3` to image id `2`.

If the `nv_counter` value is increased in `policy/policy_secure.json` at the provisioning stage, the `nv_counter` value in `policy/policy_reprovisioning_secure.json` must start from the value not less than the value in `policy/policy_secure.json` file.   
More details about provisioning and reprovisioning processes you can find in [README_CYW20829.md](https://github.com/Infineon/edgeprotecttools/blob/master/docs/README_CYW20829.md#command-provision-device)  

When preparing an image for MCUBootApp with the rollback counter support, the `edgeprotecttools` signs it with `policy/policy_secure.json` in the post-build stage of `make`. The `nv_counter` value remains the same as one in the chip or sets higher. When `edgeprotecttools` signs an image, it places the `nv-counter` value and the reprovisioning packet in TLVs with tags 0x50 (bit mask representation of the counter) and 0x51 (reprovisioning packet). MCUBootApp then parses these tags and compares the value supplied with the image against the one stored in the eFuse counter.

If image counter value is set to higher than defined for this image by `bits_per_cnt` field in policy, for example, image id 1 is provisioned to have 16 bits for its counter, but image programmed has nv counter value of 20 embedded in TLVs - MCUBootApp would discard it as invalid.

### Building MCUBootApp and BlinkyApp with rollback protection 

Examples of the build command with the rollback counter support for a `single image` and **OVERWRITE** mode:  
for MCUBootApp:  

    make clean app APP_NAME=MCUBootApp PLATFORM=CYW20829 APP_DEFAULT_POLICY=./policy/policy_secure.json BUILDCFG=Debug FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_overwrite_single.json LCS=SECURE

for BlinkyApp with TLVs containing rollback counter data:  
 - BOOT slot:  

    	make clean_boot app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=BOOT APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_overwrite_single.json  

 - UPGRADE slot:  

    	make clean_upgrade app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=UPGRADE APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_overwrite_single.json  

#### NV-counter update

To update NV-counter for an appropriate image you have to increase NV-counter in the reprovisioning policy `/policy/policy_reprovisioning_secure.json`, after that re-build the `BlinkyApp` and re-program your device.

The CYW20829/CYW89829 chip is designed so that the first stage bootloader called `BootROM` has most of the rights to modify the system - it is executed in the privileged protection context. Only BootROM can modify the content of eFuse where the NV counter is stored. BootROM supports the special type of service applications used when the user needs to modify the system. These apps are also provided with `edgeprotecttools` under `targets/cyw20829/packets/apps` or `targets/cyw89829/packets/apps`. The `reprovisioning` application is used for NV-counter updates.

To enable the rollback counter feature, one have to use a JSON flash map with the `"service_app"` section. Sample flash maps are located in `boot/cypress/platforms/memory/CYW20829/flashmap/hw_rollback_prot` or `boot/cypress/platforms/memory/CYW89829/flashmap/hw_rollback_prot`.

The service application is supplied as a precompiled binary executed from RAM by BootROM. User should program either `cyapp_reprovisioning_signed.hex` (located at `./MCUBootApp/out/CYW20829/Debug/cyapp_reprovisioning_signed.hex` or `./MCUBootApp/out/CYW89829/Debug/cyapp_reprovisioning_signed.hex`) or similar binary `./packets/apps/reprovisioning/cyapp_reprovisioning_signed.bin` (with the `"address"` specified in the `"service_app"` section of JSON flash map). Some other data is required for BootROM to execute the service app - this data is prepared by MCUBootApp.

When MCUBootApp detects that the rollback counter must be updated on CYW20829/CYW89829, it executes the function, which prepares input data and service application descriptor data and places it in flash at addresses `"params_address"` and `"desc_address"`, respectively (see the `"service_app"` section in JSON flash map). Then, it sets the special flag in the service register, which signals BootROM to launch the service application and calls a system reset. BootROM then detects the service app with its data, copies it to the corresponding addresses in RAM, and executes it. Reprovisioning app then updates the `nv-counter` value in eFuse. An automatic reset can (and for convenience should) be initiated after that. To enable this flow, `sys_reset_req` is set to `true` (`false` by default).

            "sys_reset_req": {
                "description": "Resets a device after RAM application finishes execution.",
                "value": true
            }

For more details on BootROM service applications, refer to the CYW20829/CYW89829 documentation.

#### Rollback counter behavior

**Case 1**

An image is signed using the `policy_reprovisioning_secure.json` policy with the `nv-counter` field value set to 1; the current value of NV-counter in the chip is `0` and programmed to the primary slot of MCUBootApp.

MCUBootApp validates the image in the primary slot and initiates a rollback counter update. The image in the primary slot is started after that.

**Case 2**

An image is signed using the `policy_reprovisioning_secure.json` policy with `nv-counter`, the field value is set to 2; the current value of NV-counter in the chip is `1` and programmed into the secondary slot of MCUBootApp. The upgrade type is 'swap'.

MCUBootApp validates the image in the secondary slot and initiates a firmware upgrade. After swapping the primary and 
secondary images, the firmware from the primary slot is executed immediately after the upgrade.

- If the upgraded firmware operates correctly - starts its execution and sets the confirmation flag (read more in the design.md file), then, after the next reset, MCUBootApp updates the rollback counter value as in Case 1.

- If the upgraded firmware operates incorrectly - does not start or does not set the confirmation flag, the watchdog initiates a system reset and MCUBootApp performs the `revert` operation - copies back the previous firmware from the secondary to the primary slot, marks the image in the secondary slot as invalid and executes the original firmware from the primary slot. **The rollback counter is not updated in this case.**

**Case 3**

An image is signed with the `policy_reprovisioning_secure.json` policy with `nv-counter`, the field value is set to 3; the current value of NV-counter in the chip is `4` and programmed to the secondary or primary slot of MCUBootApp. The upgrade type is 'swap'.

MCUBootApp tries to validate the image, detects that the value of the rollback counter stored in the chip is greater than the one provided with the image, and rejects such an image. The firmware in the primary slot will not start and an upgrade will not be initiated.

When the reprovisioning packet TLV is absent in the primary or secondary image TLVs, MCUBootApp marks such an image as invalid.

**Multi-image case**

See **Rollback protection Support** section for description. 

Examples of the build command with the rollback counter support for the `multi-image case`, **SWAP** upgrade mode:  

for MCUBootApp:  

    make clean app APP_NAME=MCUBootApp PLATFORM=CYW20829 APP_DEFAULT_POLICY=./policy/policy_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_swap_multi2.json LCS=SECURE USE_HW_ROLLBACK_PROT=1

for BlinkyApp with TLVs containing rollback counter data:
 - BOOT slot, IMG_ID=1:  
 
   	make clean_boot app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=BOOT APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_swap_multi2.json IMG_ID=1
 - UPGRADE slot, IMG_ID=1:  
 
    	make clean_upgrade app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=UPGRADE APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_swap_multi2.json IMG_ID=1

 - BOOT slot, IMG_ID=2:  
 
    	make clean_boot app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=BOOT APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_swap_multi2.json IMG_ID=2
    
 - UPGRADE slot, IMG_ID=2:  
    
    	make clean_upgrade app APP_NAME=BlinkyApp PLATFORM=CYW20829 IMG_TYPE=UPGRADE APP_DEFAULT_POLICY=./policy/policy_reprovisioning_secure.json FLASH_MAP=platforms/memory/CYW20829/flashmap/hw_rollback_prot/cyw20829_xip_swap_multi2.json IMG_ID=2
    
**Attention!** Don't omit `clean_boot` and `clean_upgrade` to avoid any issues!   

### Programming applications
You can find the HEX files for programming at:

for MCUBootApp: `MCUBootApp.hex` in the directory 'MCUBootApp/out/CYW20829/*{BUILDCFG}*/'

for BlinkyApp: 
 - for IMG_ID=1, BOOT slot select `BlinkyApp.hex` inside of 'BlinkyApp/**out**/CYW20829/*{BUILDCFG}*/**boot**/' 
 - for IMG_ID=1, UPGRADE slot select `BlinkyApp_upgrade.hex` inside of 'BlinkyApp/**out**/CYW20829/*{BUILDCFG}*/**upgrade**/'
 - for IMG_ID=2, BOOT slot select `BlinkyApp.hex` inside of 'BlinkyApp/**out.id2**/CYW20829/*{BUILDCFG}*/**boot**/' 
 - for IMG_ID=2, UPGRADE slot select `BlinkyApp_upgrade.hex` inside of 'BlinkyApp/**out.id2**/CYW20829/*{BUILDCFG}*/**upgrade**/'

Default **{BUILDCFG}** is 'Debug', so all previous commands for the 'multi-image' case will build a 'Debug' configuration.

#### Using OpenOCD from command line

The following instruction assumes the usage of one of Cypress KitProg3 devices and a development board.

Connect the board to your computer. Switch Kitprog3 to DAP-BULK mode by clicking the `SW3 MODE` button until `LED2 STATUS` is steady on.

Open the terminal application and execute the following commands:

    export OPENOCD_PATH=C:/Infineon/Tools/ModusToolboxProgtools-1.5/openocd

    $OPENOCD_PATH/bin/openocd -s $OPENOCD_PATH/scripts -f $OPENOCD_PATH/scripts/interface/kitprog3.cfg -c "set SMIF_BANKS { 0 {addr 0x60000000 size 0x100000 psize 0x1000 esize 0x40000} }; set DEBUG_CERTIFICATE ./packets/debug_cert.bin" -f $OPENOCD_PATH/scripts/target/infineon/cyw20829.cfg -c "init; reset init; cmsis_flash init; program ./BlinkyApp/out/CYW20829/Debug/upgrade/BlinkyApp.hex; shutdown"

**Warning**

The application slot is automatically erased by `flash erase_address` before executing the `program` command.
 
